{"version":3,"sources":["./src/assets/dist/esm/kup-graphic-cell.entry.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAA+D;;AAE/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA,4DAA4D;AAC5D;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO,GAAG,OAAO,GAAG,OAAO;AACjD;AACA;;AAEA;AACA;AACA,QAAQ,4DAAgB;AACxB;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,8DAA8D;AAC9D;AACA;AACA,+DAA+D;AAC/D;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA,iDAAiD;AACjD,oDAAoD;AACpD,oDAAoD;AACpD,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA,kDAAkD,kBAAkB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4DAAC,YAAY,0EAA0E;AACvG;AACA,2BAA2B;AAC3B;AACA,MAAM;AACN;;AAE8C","file":"15-es2015.js","sourcesContent":["import { r as registerInstance, h } from './chunk-1851c479.js';\n\nfunction getColorFromString(rgb) {\r\n    const rIndex = rgb.indexOf('R');\r\n    const gIndex = rgb.indexOf('G');\r\n    const bIndex = rgb.indexOf('B');\r\n    if (rIndex < 0 || gIndex < 0 || bIndex < 0) {\r\n        return;\r\n    }\r\n    const r = rgb.substring(rIndex + 1, rIndex + 4);\r\n    const g = rgb.substring(gIndex + 1, gIndex + 4);\r\n    const b = rgb.substring(bIndex + 1, bIndex + 4);\r\n    try {\r\n        return new Color(parseInt(r), parseInt(g), parseInt(b));\r\n    }\r\n    catch (e) {\r\n        console.error(e);\r\n    }\r\n    return null;\r\n}\n\nclass GraphicElement {\r\n    constructor() {\r\n        this.width = 100.0;\r\n        this.height = 100.0;\r\n        this.color = null;\r\n        this.shape = 'bar';\r\n    }\r\n    init(markers) {\r\n        markers.forEach((marker) => {\r\n            if (marker.toUpperCase().startsWith('HEIGHT;')) {\r\n                this.initHeight(marker);\r\n            }\r\n            else if (marker.toUpperCase().startsWith('SHAPE;')) {\r\n                this.initShape(marker);\r\n            }\r\n            else if (marker.toUpperCase().startsWith('BCOLOR;')) ;\r\n            else {\r\n                this.initColor(marker);\r\n            }\r\n        });\r\n    }\r\n    initColor(rgb) {\r\n        if (rgb.length > 11 && this.isValidColor(rgb)) {\r\n            this.color = getColorFromString(rgb.substring(0, 12));\r\n            try {\r\n                this.width = parseFloat(rgb.substring(13).replace(',', '.'));\r\n            }\r\n            catch (e) {\r\n                console.error(e);\r\n            }\r\n        }\r\n        else if (rgb.startsWith('*NONE')) {\r\n            try {\r\n                this.width = parseFloat(rgb.substring(6).replace(',', '.'));\r\n            }\r\n            catch (e) {\r\n                console.error(e);\r\n            }\r\n        }\r\n    }\r\n    isTrasparent() {\r\n        return this.color === null;\r\n    }\r\n    initHeight(height) {\r\n        if (height) {\r\n            const toBeParsed = height\r\n                .substring('HEIGHT;'.length)\r\n                .replace(',', '.');\r\n            try {\r\n                this.height = parseFloat(toBeParsed);\r\n            }\r\n            catch (err) {\r\n                console.error(err);\r\n            }\r\n        }\r\n    }\r\n    initShape(shape) {\r\n        shape = shape.substring('SHAPE;'.length);\r\n        const vLastSemicolonIndex = shape.indexOf(';');\r\n        let vShapeTypeString = shape;\r\n        if (vLastSemicolonIndex > -1) {\r\n            vShapeTypeString = shape.substring(0, vLastSemicolonIndex);\r\n            try {\r\n                this.width = parseFloat(shape.substring(vLastSemicolonIndex + 1).replace(',', '.'));\r\n            }\r\n            catch (err) {\r\n                console.error(err);\r\n            }\r\n        }\r\n        switch (vShapeTypeString.toLocaleLowerCase()) {\r\n            case 'circle':\r\n                this.shape = 'circle';\r\n                break;\r\n            case 'tril':\r\n                this.shape = 'tril';\r\n                break;\r\n            case 'trir':\r\n                this.shape = 'trir';\r\n                break;\r\n        }\r\n    }\r\n    isValidColor(color) {\r\n        if (!color) {\r\n            return false;\r\n        }\r\n        color = color.trim();\r\n        const vRgb = [];\r\n        let vError = false;\r\n        let vColorKey = null;\r\n        // red\r\n        let vIndex = color.indexOf('R');\r\n        if (vIndex > -1) {\r\n            vColorKey = color.substring(vIndex + 1, vIndex + 4);\r\n            vRgb[0] = parseInt(vColorKey);\r\n            if (isNaN(vRgb[0])) {\r\n                vError = true;\r\n            }\r\n        }\r\n        // green\r\n        vIndex = color.indexOf('G');\r\n        if (vIndex > -1) {\r\n            vColorKey = color.substring(vIndex + 1, vIndex + 4);\r\n            vRgb[1] = parseInt(vColorKey);\r\n            if (isNaN(vRgb[1])) {\r\n                vError = true;\r\n            }\r\n        }\r\n        // blue\r\n        vIndex = color.indexOf('B');\r\n        if (vIndex > -1) {\r\n            vColorKey = color.substring(vIndex + 1, vIndex + 4);\r\n            vRgb[2] = parseInt(vColorKey);\r\n            if (isNaN(vRgb[2])) {\r\n                vError = true;\r\n            }\r\n        }\r\n        if (vError) {\r\n            const vIndexR = color.indexOf('R');\r\n            const vIndexG = color.indexOf('G');\r\n            const vIndexB = color.indexOf('B');\r\n            // check R\r\n            vColorKey = color.substring(vIndexR + 1, vIndexG);\r\n            vRgb[0] = parseInt(vColorKey);\r\n            if (isNaN(vRgb[0])) {\r\n                vError = true;\r\n            }\r\n            // Check G\r\n            vColorKey = color.substring(vIndexG + 1, vIndexB);\r\n            vRgb[1] = parseInt(vColorKey);\r\n            if (isNaN(vRgb[1])) {\r\n                vError = true;\r\n            }\r\n            // Check B\r\n            vColorKey = color.substring(vIndexB + 1);\r\n            vRgb[2] = parseInt(vColorKey);\r\n            if (isNaN(vRgb[2])) {\r\n                vError = true;\r\n            }\r\n            if (vError) {\r\n                return false;\r\n            }\r\n        }\r\n        // Check if all values are between 0 and 255\r\n        if (vRgb[0] < 0 ||\r\n            vRgb[0] > 255 ||\r\n            vRgb[1] < 0 ||\r\n            vRgb[1] > 255 ||\r\n            vRgb[2] < 0 ||\r\n            vRgb[2] > 255) {\r\n            return false;\r\n        }\r\n        // All good\r\n        return true;\r\n    }\r\n    getHeight() {\r\n        return this.height;\r\n    }\r\n    getWidth() {\r\n        return this.width;\r\n    }\r\n    getShape() {\r\n        return this.shape;\r\n    }\r\n    getColor() {\r\n        return this.color;\r\n    }\r\n}\r\nclass Color {\r\n    constructor(r, g, b) {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n    }\r\n    toString() {\r\n        return `rgb(${this.r},${this.g},${this.b})`;\r\n    }\r\n}\n\nclass KupGraphicCell {\n    constructor(hostRef) {\n        registerInstance(this, hostRef);\n        this.height = 30;\n        this.width = 300;\n        this.graphic_element_marker_splitter = '\\\\\\\\';\n        this.graphic_element_splitter = '\\\\\\\\AND\\\\\\\\';\n        this.background_color = 'BCOLOR;R255G000B000';\n        this.default_color = new Color(0, 0, 0);\n    }\n    onValueChange() {\n        this.draw();\n    }\n    // lifecycle\n    componentDidLoad() {\n        this.draw();\n    }\n    // private methods\n    draw() {\n        if (!this.value) {\n            return;\n        }\n        if (this.canvas.getContext) {\n            this.ctx = this.canvas.getContext('2d');\n            this.drawGraphicCell();\n        }\n    }\n    drawGraphicCell() {\n        const vGraphicElementDefinitionArr = this.value.split(this.graphic_element_splitter);\n        vGraphicElementDefinitionArr.forEach((graphicElem, index) => {\n            let vShapeMarker = 'SHAPE;BAR';\n            let vBGColorMarker = this.background_color;\n            let vHeightPctMarker = 'HEIGHT;100';\n            const vMarkersArray = graphicElem.split(this.graphic_element_marker_splitter);\n            const shapesArray = [];\n            const vSeparatorsList = [];\n            vMarkersArray.forEach((vString) => {\n                if (this.isShapeMarker(vString)) {\n                    vShapeMarker = vString;\n                }\n                else if (this.isBgColorMarker(vString)) {\n                    vBGColorMarker = vString;\n                }\n                else if (this.isHeightMarker(vString)) {\n                    vHeightPctMarker = vString;\n                }\n                else if (this.isDecoratorMarker(vString)) {\n                    vSeparatorsList.push(vString);\n                }\n                else {\n                    shapesArray.push(vString);\n                }\n            });\n            const vGraphicElementArray = shapesArray.map((shape) => {\n                const elem = new GraphicElement();\n                elem.init([\n                    vShapeMarker,\n                    vBGColorMarker,\n                    vHeightPctMarker,\n                    shape,\n                ]);\n                return elem;\n            });\n            // first element -> setting background\n            if (index === 0 && vBGColorMarker !== this.background_color) {\n                const bgColor = getColorFromString(vBGColorMarker.substring('BCOLOR;'.length));\n                this.drawRect(0, 0, this.canvas.width, this.canvas.height, bgColor);\n            }\n            let startX = 0;\n            vGraphicElementArray.forEach((elem) => {\n                switch (elem.getShape()) {\n                    case 'circle':\n                        startX = this.getNewStarXFromCircle(startX, elem);\n                        break;\n                    case 'tril':\n                        startX = this.getNewStarXFromTril(startX, elem);\n                        break;\n                    case 'trir':\n                        startX = this.getNewStarXFromTrir(startX, elem);\n                        break;\n                    default:\n                        // bar\n                        startX = this.getNewStarXFromBar(startX, elem);\n                        break;\n                }\n            });\n            vSeparatorsList.forEach((sep) => {\n                if (sep.startsWith('SEP') || sep.startsWith('DIV')) {\n                    this.drawSeparator(sep);\n                }\n                else if (sep.startsWith('ARW')) {\n                    this.drawArrow(sep);\n                }\n                else if (sep.startsWith('GRID')) {\n                    this.drawGrid(sep);\n                }\n            });\n        });\n    }\n    isShapeMarker(value) {\n        return value && value.toUpperCase().startsWith('SHAPE;');\n    }\n    isBgColorMarker(value) {\n        return value && value.toUpperCase().startsWith('BCOLOR;');\n    }\n    isHeightMarker(value) {\n        return value && value.toUpperCase().startsWith('HEIGHT;');\n    }\n    isDecoratorMarker(value) {\n        return (value &&\n            (value.toUpperCase().startsWith('SEP;') ||\n                value.toUpperCase().startsWith('DIV;') ||\n                value.toUpperCase().startsWith('ARW;') ||\n                value.toUpperCase().startsWith('GRID;')));\n    }\n    getDim(dimPixel, dimPerc) {\n        return Math.floor((dimPixel / 100) * dimPerc);\n    }\n    getNewStarXFromBar(startX, elem) {\n        const elemWidth = this.getDim(this.canvas.width, elem.getWidth());\n        const elemHeight = this.getDim(this.canvas.height, elem.getHeight());\n        const y = this.canvas.height - elemHeight;\n        if (!elem.isTrasparent()) {\n            this.drawRect(startX, y, elemWidth, elemHeight, elem.getColor());\n        }\n        return elemWidth;\n    }\n    getNewStarXFromCircle(startX, circle) {\n        const newStartX = this.getDim(this.canvas.width, circle.getWidth());\n        const x = (startX + newStartX) / 2;\n        if (!circle.isTrasparent()) {\n            this.drawArc(x, this.canvas.height / 2, circle.getColor());\n        }\n        return newStartX;\n    }\n    getNewStarXFromTril(startX, triLeft) {\n        const newStartX = this.getDim(this.canvas.width, triLeft.getWidth());\n        if (!triLeft.isTrasparent()) {\n            this.drawTri(newStartX, 0, startX, this.canvas.height / 2, triLeft.getColor());\n        }\n        return newStartX;\n    }\n    getNewStarXFromTrir(startX, triRight) {\n        const newStartX = this.getDim(this.canvas.width, triRight.getWidth());\n        if (!triRight.isTrasparent()) {\n            this.drawTri(startX, 0, newStartX, this.canvas.height / 2, triRight.getColor());\n        }\n        return newStartX;\n    }\n    drawArc(x, radius, color) {\n        this.ctx.fillStyle = color.toString();\n        this.ctx.beginPath();\n        this.ctx.arc(x, radius, radius, 0, 2 * Math.PI, true);\n        this.ctx.fill();\n    }\n    drawRect(x, y, width, height, color) {\n        this.ctx.fillStyle = color.toString();\n        this.ctx.fillRect(x, y, width, height);\n    }\n    drawTri(x1, y1, x2, y2, color) {\n        this.ctx.fillStyle = color.toString();\n        this.ctx.beginPath();\n        this.ctx.moveTo(x1, y1);\n        this.ctx.lineTo(x2, y2);\n        this.ctx.lineTo(x1, this.canvas.height);\n        this.ctx.fill();\n    }\n    drawArrow(sep) {\n        let vPart = sep.substring('ARW;'.length);\n        if (vPart.indexOf(',') > -1) {\n            vPart = vPart.replace(',', '.');\n        }\n        this.ctx.fillStyle = this.default_color.toString();\n        const startX = this.getDim(this.canvas.width, parseFloat(vPart));\n        const height = this.canvas.height;\n        const arrSpan = Math.floor(height / 3);\n        const arrSpanHalf = arrSpan / 2;\n        this.ctx.beginPath();\n        this.ctx.moveTo(startX, 0);\n        this.ctx.lineTo(startX - arrSpan, height / 2);\n        this.ctx.lineTo(startX - arrSpanHalf, height / 2);\n        this.ctx.lineTo(startX - arrSpanHalf, height);\n        this.ctx.lineTo(startX + arrSpanHalf, height);\n        this.ctx.lineTo(startX + arrSpanHalf, height / 2);\n        this.ctx.lineTo(startX + arrSpan, height / 2);\n        this.ctx.fill();\n    }\n    drawGrid(sep) {\n        let vPart = sep.substring('GRID;'.length);\n        if (vPart.indexOf(',') > -1) {\n            vPart = vPart.replace(',', '.');\n        }\n        const vTickNum = parseInt(vPart);\n        const vTickDist = this.canvas.width / vTickNum;\n        const tickH = this.canvas.height / 5;\n        const y = this.canvas.height - tickH;\n        const tickW = 1;\n        for (let i = vTickDist; i < this.canvas.width; i = i + vTickDist) {\n            this.drawRect(i, y, tickW, tickH, this.default_color);\n        }\n    }\n    drawSeparator(sep) {\n        const vSeparatorPart = sep.substring('SEP;'.length).split(';');\n        let vColor = 'R000G000B000';\n        let vThickness = 2;\n        let vPositionPart = vSeparatorPart[0];\n        if (vSeparatorPart.length > 1) {\n            vColor = vSeparatorPart[1];\n        }\n        if (vSeparatorPart.length > 2) {\n            vThickness = parseInt(vSeparatorPart[2]);\n        }\n        if (vPositionPart.indexOf(',') > -1) {\n            vPositionPart = vPositionPart.replace(',', '.');\n        }\n        const x = this.getDim(this.canvas.width, parseFloat(vPositionPart));\n        this.drawRect(x, 0, vThickness, this.canvas.height, getColorFromString(vColor));\n    }\n    render() {\n        return (h(\"canvas\", { ref: (el) => (this.canvas = el), height: this.height, width: this.width }, this.value));\n    }\n    static get watchers() { return {\n        \"value\": [\"onValueChange\"]\n    }; }\n}\n\nexport { KupGraphicCell as kup_graphic_cell };\n"],"sourceRoot":"webpack:///"}